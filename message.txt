/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   yohai.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rferradi <rferradi@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/06/15 12:12:25 by yohan             #+#    #+#             */
/*   Updated: 2023/02/14 13:26:47 by rferradi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3d.h"
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define X_EVENT_KEY_PRESS	2
#define X_EVENT_KEY_EXIT	17
#define mapWidth 24
#define mapHeight 24
#define width 640
#define height 480

typedef struct	s_info
{
	double posX;
	double posY;
	double dirX;
	double dirY;
	double planeX;
	double planeY;
	void	*mlx;
	void	*win;
	double	moveSpeed;
	double	rotSpeed;
}				t_info;

int	worldmap[14][29] = {
						{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
						{1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
						{1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,1},
						{1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
						{1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1},
						{1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,1},
						{1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1},
						{1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,0,0,1},
						{1,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1},
						{1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
						{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,0,1},
						{1,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,0,0,1},
						{1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,0,0,1},
						{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
						};

void	verLine(t_info *info, int x, int y1, int y2, int color)
{
	int	y;

	y = y1;
	while (y <= y2)
	{
		mlx_pixel_put(info->mlx, info->win, x, y, color);
		y++;
	}
}

void	calc(t_info *info)
{
	int	x;
	t_data *d;

	d = starton();

	x = 0;
	while (x < width)
	{
		info->cameraX = 2 * x / (double)width - 1;
		info->raydir.x = info->dir.x + info->planeX * info->cameraX;
		info->raydir.y = info->dir.y + info->planeY * info->cameraX;
		
		info->map.x = (int)info->pos.x;
		info->map.y = (int)info->pos.y;

		//length of ray from current position to next x or y-side
		
		 //length of ray from one x or y-side to next x or y-side
		double deltaDistX = fabs(1 / info->raydir.x);
		double deltaDistY = fabs(1 / info->raydir.y);
		double perpWallDist;
		
		//what direction to step in x or y-direction (either +1 or -1)
		int stepX;
		int stepY;
		
		int hit = 0; //was there a wall hit?
		int side; //was a NS or a EW wall hit?

		if (info->raydir.x < 0)
		{
			stepX = -1;
			info->sidedist.x = (info->pos.x - info->map.x) * deltaDistX;
		}
		else
		{
			stepX = 1;
			info->sidedist.x = (info->map.x + 1.0 - info->pos.x) * deltaDistX;
		}
		if (info->raydir.y < 0)
		{
			stepY = -1;
			info->sidedist.y = (info->pos.y - info->map.y) * deltaDistY;
		}
		else
		{
			stepY = 1;
			info->sidedist.y = (info->map.y + 1.0 - info->pos.y) * deltaDistY;
		}

		while (hit == 0)
		{
			//jump to next map square, OR in x-direction, OR in y-direction
			if (info->sidedist.x < info->sidedist.y)
			{
				info->sidedist.x += deltaDistX;
				info->map.x += stepX;
				side = 0;
			}
			else
			{
				info->sidedist.y += deltaDistY;
				info->map.y += stepY;
				side = 1;
			}
			//Check if ray has hit a wall
			if (worldmap[info->map.x][info->map.y] > 0) hit = 1;
		}
		if (side == 0)
			perpWallDist = (info->map.x - info->pos.x + (1 - stepX) / 2) / info->raydir.x;
		else
			perpWallDist = (info->map.y - info->pos.y + (1 - stepY) / 2) / info->raydir.y;

		//Calculate height of line to draw on screen
		int lineHeight = (int)(height / perpWallDist);

		//calculate lowest and highest pixel to fill in current stripe
		int drawStart = -lineHeight / 2 + height / 2;
		if(drawStart < 0)
			drawStart = 0;
		int drawEnd = lineHeight / 2 + height / 2;
		if(drawEnd >= height)
			drawEnd = height - 1;

		int	color;
		if (worldmap[info->map.y][info->map.x] == 1)
			color = 0xFF0000;
		else if (worldmap[info->map.y][info->map.x] == 2)
			color = 0x00FF00;
		else if (worldmap[info->map.y][info->map.x] == 3)
			color = 0x0000FF;
		else if (worldmap[info->map.y][info->map.x] == 4)
			color = 0xFFFFFF;
		else
			color = 0xFFFF00;
		
		if (side == 1)
			color = color / 2;

		verLine(info, x, drawStart, drawEnd, color);
		verLine(info, x, 0, drawStart, 0xf133b61);
		verLine(info, x, drawEnd, height, 0x00FF00);
		
		x++;
	}
}

int	main_loop(t_info *info)
{
	// mlx_put_image_to_window(info->mlx, info->win, &info->img, 0, 0);

	return (0);
}

int	key_press(int key, t_info *info)
{
	t_data *d = starton();
	if (key == 'w')
	{
		if (!worldmap[(int)(info->pos.x + info->dir.x * info->moveSpeed)][(int)(info->pos.y)])
			info->pos.x += info->dir.x * info->moveSpeed;
		if (!worldmap[(int)(info->pos.x)][(int)(info->pos.y + info->dir.y * info->moveSpeed)])
			info->pos.y += info->dir.y * info->moveSpeed;
	}
	//move backwards if no wall behind you
	if (key == 's')
	{
		if (!worldmap[(int)(info->pos.x - info->dir.x * info->moveSpeed)][(int)(info->pos.y)])
			info->pos.x -= info->dir.x * info->moveSpeed;
		if (!worldmap[(int)(info->pos.x)][(int)(info->pos.y - info->dir.y * info->moveSpeed)])
			info->pos.y -= info->dir.y * info->moveSpeed;
	}
	//rotate to the right
	if (key == 'd')
	{
		//both camera direction and camera plane must be rotated
		double oldDirX = info->dir.x;
		info->dir.x = info->dir.x * cos(-info->rotSpeed) - info->dir.y * sin(-info->rotSpeed);
		info->dir.y = oldDirX * sin(-info->rotSpeed) + info->dir.y * cos(-info->rotSpeed);
		double oldPlaneX = info->planeX;
		info->planeX = info->planeX * cos(-info->rotSpeed) - info->planeY * sin(-info->rotSpeed);
		info->planeY = oldPlaneX * sin(-info->rotSpeed) + info->planeY * cos(-info->rotSpeed);
	}
	//rotate to the left
	if (key == 'a')
	{
		//both camera direction and camera plane must be rotated
		double oldDirX = info->dir.x;
		info->dir.x = info->dir.x * cos(info->rotSpeed) - info->dir.y * sin(info->rotSpeed);
		info->dir.y = oldDirX * sin(info->rotSpeed) + info->dir.y * cos(info->rotSpeed);
		double oldPlaneX = info->planeX;
		info->planeX = info->planeX * cos(info->rotSpeed) - info->planeY * sin(info->rotSpeed);
		info->planeY = oldPlaneX * sin(info->rotSpeed) + info->planeY * cos(info->rotSpeed);
	}
	if (key == 'q')
		exit(0);
	calc(info);

	return (0);
}

void	init_info(t_info *info, t_data *data)
{
	info->pos.x = 5;
	info->pos.y = 5;
	// printf("lala\n");
	// printf("INIT x = %f, y = %f info x = %f   y = %f\n", data->p.x, data->p.y, info->pos.x, info->pos.y);
	info->dir.x = -1;
	info->dir.y = 0;
	info->planeX = 0;
	info->planeY = 0.66;
	info->moveSpeed = 0.2;
	info->rotSpeed = 0.05;
}


int cross(t_info *info)
{
	mlx_loop_end(info->mlx);
	return(0);
}

void	array_to_int(t_data *data)
{
	int i = 0;
	int j;
	int	**mapi = malloc(sizeof(int*) * (data->y + 100));
	while (data->map[i])
	{
		j = 0;
		mapi[i] = malloc(sizeof(int) * (data->x + 100));
		while (data->map[i][j])
		{
			if (data->map[i][j] == '1')
				mapi[i][j] = 1;
			else if (data->map[i][j] == '0')
				mapi[i][j] = 0;
			else
				mapi[i][j] = data->map[i][j];
		j++;
		}
		i++;
	}
	data->mapint = worldmap;
}

int	ft_graphical(t_data *data, t_info *info)
{
	// t_info info;
	// array_to_int(data->map);
	array_to_int(data);
	info->mlx = mlx_init();
	printf("GRAPH x = %f, y = %f\n", data->p.x, data->p.y);
	init_info(info, data);
	
	info->win = mlx_new_window(info->mlx, width, height, "mlx");
	mlx_hook(info->win, 0, 1L<<0, &deal_key , info);
	mlx_key_hook(info->win, key_press, info);
	mlx_loop_hook(info->mlx, &main_loop, info);
	mlx_hook(info->win, 17, 0, &cross , info);

	mlx_loop(info->mlx);
	ft_destroy(info);
	return (0);
}